#cloud-config
write_files:
  - path: /etc/systemd/system/control-plane.service
    content: |
      [Unit]
      Description=Envoy Control Plane
      After=network.target

      [Service]
      Type=simple
      User=root
      WorkingDirectory=/opt/control-plane
      ExecStart=/opt/control-plane/control-plane
      Restart=always
      RestartSec=10

      StandardOutput=journal
      StandardError=journal

      [Install]
      WantedBy=multi-user.target

  - path: /opt/control-plane/main.go
    content: |
      package main

      import (
          "context"
          "fmt"
          "log"
          "net"
          "time"

          "github.com/Azure/azure-sdk-for-go/sdk/azidentity"
          "github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/compute/armcompute/v5"
          cluster "github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3"
          core "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
          endpoint "github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3"
          listener "github.com/envoyproxy/go-control-plane/envoy/config/listener/v3"
          route "github.com/envoyproxy/go-control-plane/envoy/config/route/v3"
          clusterservice "github.com/envoyproxy/go-control-plane/envoy/service/cluster/v3"
          discoverygrpc "github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3"
          endpointservice "github.com/envoyproxy/go-control-plane/envoy/service/endpoint/v3"
          listenerservice "github.com/envoyproxy/go-control-plane/envoy/service/listener/v3"
          routeservice "github.com/envoyproxy/go-control-plane/envoy/service/route/v3"
          hcm "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3"
          "github.com/envoyproxy/go-control-plane/pkg/cache/types"
          "github.com/envoyproxy/go-control-plane/pkg/cache/v3"
          "github.com/envoyproxy/go-control-plane/pkg/resource/v3"
          "github.com/envoyproxy/go-control-plane/pkg/server/v3"
          "google.golang.org/grpc"
          "google.golang.org/grpc/keepalive"
          "google.golang.org/protobuf/types/known/anypb"
          "google.golang.org/protobuf/types/known/durationpb"
      )

      const (
          grpcPort        = 18000
          subscriptionID  = "${subscription_id}"
          resourceGroup   = "${resource_group_name}"
          vmssName        = "${vmss_name}"
          pollingInterval = 30 * time.Second
      )

      type AzureDiscovery struct {
          vmClient *armcompute.VirtualMachineScaleSetVMsClient
          ctx      context.Context
      }

      func NewAzureDiscovery(ctx context.Context) (*AzureDiscovery, error) {
          cred, err := azidentity.NewDefaultAzureCredential(nil)
          if err != nil {
              return nil, fmt.Errorf("failed to get credentials: %v", err)
          }

          vmClient, err := armcompute.NewVirtualMachineScaleSetVMsClient(subscriptionID, cred, nil)
          if err != nil {
              return nil, fmt.Errorf("failed to create VM client: %v", err)
          }

          return &AzureDiscovery{
              vmClient: vmClient,
              ctx:      ctx,
          }, nil
      }

      func (a *AzureDiscovery) GetVMSSInstances() ([]string, error) {
          pager := a.vmClient.NewListPager(resourceGroup, vmssName, nil)

          instanceCount := 0
          for pager.More() {
              page, err := pager.NextPage(a.ctx)
              if err != nil {
                  return nil, fmt.Errorf("failed to list instances: %v", err)
              }
              instanceCount += len(page.Value)
          }

          if instanceCount == 0 {
              return []string{}, nil
          }

          // Generate IPs based on Azure's default pattern
          // IMPORTANT: Backends are in 10.1.2.0/24 subnet, starting from .5
          var ips []string
          for i := 0; i < instanceCount; i++ {
              ips = append(ips, fmt.Sprintf("10.1.2.%d", 5+i))
          }

          return ips, nil
      }

      func makeCluster(clusterName string) *cluster.Cluster {
          return &cluster.Cluster{
              Name:                 clusterName,
              ConnectTimeout:       durationpb.New(5 * time.Second),
              ClusterDiscoveryType: &cluster.Cluster_Type{Type: cluster.Cluster_EDS},
              EdsClusterConfig: &cluster.Cluster_EdsClusterConfig{
                  EdsConfig: &core.ConfigSource{
                      ResourceApiVersion: core.ApiVersion_V3,
                      ConfigSourceSpecifier: &core.ConfigSource_Ads{
                          Ads: &core.AggregatedConfigSource{},
                      },
                  },
              },
          }
      }

      func makeEndpoint(clusterName string, ips []string) *endpoint.ClusterLoadAssignment {
          var endpoints []*endpoint.LbEndpoint

          for _, ip := range ips {
              endpoints = append(endpoints, &endpoint.LbEndpoint{
                  HostIdentifier: &endpoint.LbEndpoint_Endpoint{
                      Endpoint: &endpoint.Endpoint{
                          Address: &core.Address{
                              Address: &core.Address_SocketAddress{
                                  SocketAddress: &core.SocketAddress{
                                      Protocol: core.SocketAddress_TCP,
                                      Address:  ip,
                                      PortSpecifier: &core.SocketAddress_PortValue{
                                          PortValue: 8080,
                                      },
                                  },
                              },
                          },
                      },
                  },
              })
          }

          return &endpoint.ClusterLoadAssignment{
              ClusterName: clusterName,
              Endpoints: []*endpoint.LocalityLbEndpoints{{
                  LbEndpoints: endpoints,
              }},
          }
      }

      func makeRoute(routeName, clusterName string) *route.RouteConfiguration {
          return &route.RouteConfiguration{
              Name: routeName,
              VirtualHosts: []*route.VirtualHost{{
                  Name:    "backend",
                  Domains: []string{"*"},
                  Routes: []*route.Route{{
                      Match: &route.RouteMatch{
                          PathSpecifier: &route.RouteMatch_Prefix{
                              Prefix: "/",
                          },
                      },
                      Action: &route.Route_Route{
                          Route: &route.RouteAction{
                              ClusterSpecifier: &route.RouteAction_Cluster{
                                  Cluster: clusterName,
                              },
                          },
                      },
                  }},
              }},
          }
      }

      func makeHTTPListener(listenerName, routeName string) *listener.Listener {
          manager := &hcm.HttpConnectionManager{
              StatPrefix: "ingress_http",
              RouteSpecifier: &hcm.HttpConnectionManager_Rds{
                  Rds: &hcm.Rds{
                      RouteConfigName: routeName,
                      ConfigSource: &core.ConfigSource{
                          ResourceApiVersion: core.ApiVersion_V3,
                          ConfigSourceSpecifier: &core.ConfigSource_Ads{
                              Ads: &core.AggregatedConfigSource{},
                          },
                      },
                  },
              },
              HttpFilters: []*hcm.HttpFilter{{
                  Name: "envoy.filters.http.router",
              }},
          }

          pbst, err := anypb.New(manager)
          if err != nil {
              panic(err)
          }

          return &listener.Listener{
              Name: listenerName,
              Address: &core.Address{
                  Address: &core.Address_SocketAddress{
                      SocketAddress: &core.SocketAddress{
                          Protocol: core.SocketAddress_TCP,
                          Address:  "0.0.0.0",
                          PortSpecifier: &core.SocketAddress_PortValue{
                              PortValue: 8080,
                          },
                      },
                  },
              },
              FilterChains: []*listener.FilterChain{{
                  Filters: []*listener.Filter{{
                      Name: "envoy.filters.network.http_connection_manager",
                      ConfigType: &listener.Filter_TypedConfig{
                          TypedConfig: pbst,
                      },
                  }},
              }},
          }
      }

      func generateSnapshot(version string, ips []string) (*cache.Snapshot, error) {
          return cache.NewSnapshot(
              version,
              map[resource.Type][]types.Resource{
                  resource.ClusterType:  {makeCluster("backend_cluster")},
                  resource.RouteType:    {makeRoute("local_route", "backend_cluster")},
                  resource.ListenerType: {makeHTTPListener("listener_0", "local_route")},
                  resource.EndpointType: {makeEndpoint("backend_cluster", ips)},
              },
          )
      }

      func main() {
          ctx := context.Background()

          log.Println("Starting Envoy control plane...")

          discovery, err := NewAzureDiscovery(ctx)
          if err != nil {
              log.Fatalf("Failed to create Azure discovery: %v", err)
          }

          snapshotCache := cache.NewSnapshotCache(false, cache.IDHash{}, nil)
          srv := server.NewServer(ctx, snapshotCache, nil)

          // Discovery loop
          go func() {
              version := 1
              for {
                  log.Printf("Polling Azure for VMSS instances (attempt %d)...", version)

                  ips, err := discovery.GetVMSSInstances()
                  if err != nil {
                      log.Printf("ERROR: Failed to get VMSS instances: %v", err)
                      time.Sleep(pollingInterval)
                      continue
                  }

                  if len(ips) == 0 {
                      log.Printf("WARNING: No instances discovered")
                  } else {
                      log.Printf("SUCCESS: Discovered %d instances: %v", len(ips), ips)
                  }

                  snapshot, err := generateSnapshot(fmt.Sprintf("%d", version), ips)
                  if err != nil {
                      log.Printf("ERROR: Failed to generate snapshot: %v", err)
                      time.Sleep(pollingInterval)
                      continue
                  }

                  if err := snapshotCache.SetSnapshot(ctx, "envoy-node-1", snapshot); err != nil {
                      log.Printf("ERROR: Failed to set snapshot: %v", err)
                  } else {
                      log.Printf("SUCCESS: Updated snapshot to version %d", version)
                  }

                  version++
                  time.Sleep(pollingInterval)
              }
          }()

          // Start gRPC server
          grpcServer := grpc.NewServer(
              grpc.KeepaliveParams(keepalive.ServerParameters{
                  Time:    30 * time.Second,
                  Timeout: 5 * time.Second,
              }),
          )

          // Register xDS services
          discoverygrpc.RegisterAggregatedDiscoveryServiceServer(grpcServer, srv)
          endpointservice.RegisterEndpointDiscoveryServiceServer(grpcServer, srv)
          clusterservice.RegisterClusterDiscoveryServiceServer(grpcServer, srv)
          routeservice.RegisterRouteDiscoveryServiceServer(grpcServer, srv)
          listenerservice.RegisterListenerDiscoveryServiceServer(grpcServer, srv)

          lis, err := net.Listen("tcp", fmt.Sprintf(":%d", grpcPort))
          if err != nil {
              log.Fatalf("Failed to listen on port %d: %v", grpcPort, err)
          }

          log.Printf("Control plane listening on :%d", grpcPort)
          if err := grpcServer.Serve(lis); err != nil {
              log.Fatalf("Failed to serve: %v", err)
          }
      }

  - path: /opt/control-plane/go.mod
    content: |
      module control-plane

      go 1.21

      require (
          github.com/Azure/azure-sdk-for-go/sdk/azidentity v1.5.1
          github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/compute/armcompute/v5 v5.4.0
          github.com/envoyproxy/go-control-plane v0.12.0
          google.golang.org/grpc v1.60.1
          google.golang.org/protobuf v1.32.0
      )

runcmd:
  - |
    set -e
    apt-get update
    apt-get install -y curl
    curl -fsSL https://go.dev/dl/go1.21.5.linux-amd64.tar.gz | tar -C /usr/local -xz

    export HOME=/root
    export GOPATH=/root/go
    export PATH=/usr/local/go/bin:$PATH

    cd /opt/control-plane
    go version
    go mod tidy
    go build -o control-plane main.go

    systemctl daemon-reload
    systemctl enable --now control-plane

    echo "Control plane deployment completed"
